/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/*
browsers are getting better and better
so now we don't need normalize.css for cross browser reset
we can just simply use the universal selector to do it
*/
*,
*::after,
*::before {
  margin: 0;
  padding: 0;

  box-sizing: inherit; /* force all to inherit box-sizing (from body), which by default is not inherited */
  /* better practice: whenever we can use inheritance, we should use it and avoid universal selector */

}

html {
  /* change this to change all other elements' sizes globally */
  /*font-size: 10px; !* makes life easier, 1rem is now 10px *!*/

  /* However, changing font-size above is not a good practice
   this overrides browser defined font-size,
   some people may change browser font-size, e.g. people with bad sight may increase the font size
   */

  /* better practice, so this doesn't override browser defined one
  but calculate font size based on it*/
  font-size: 62.5%; /* 10/16 = 0.625 */
}

/*
body is the parent of all the other elements
and font properties are usually inherited
so they will be applied to all child elements
this is more efficient and better practice, compared to putting all in universal selector
everything related to font we always specify here
*/
body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  line-height: 1.7;
  color: #777;
  padding: 3rem; /* to make entire body has a white border */

  box-sizing: border-box;
}

.header {
  height: 95vh;
  background-image: linear-gradient(
      to right bottom,
      rgba(126, 213, 111, 0.8),
      rgba(40, 180, 131, 0.8)
  ), url(../img/hero.jpg);
  background-size: cover; /* cover means always try to fit */
  background-position: top; /* the fixed edge of the image */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%); /* can use online css clip-path maker */

  position: relative; /* if child elements are positioned using 'absolute', this will be the origin */
}

/* difference between viewport height and percentage
viewport size is the browser window size which includes scrollbar
while % is the actual element w/h
also, vw/vh refers to viewport size no matter how nested the element is
in short,
for width, % may be better (so don't worry about scrollbar)
for height, vh may be better (can't make an element 100% height with %)
reference: https://bitsofco.de/viewport-vs-percentage-units/
*/

.header__logo-box {
  position: absolute;
  top: 4rem; /* count from the first relative-positioned ancestor */
  left: 4rem;
}

.header__logo {
  /* the width will scale accordingly,
   can also control width and let browser figure out the height as well */
  height: 3.5rem;
}

.header__text-box {
  position: absolute;
  top: 40%; /* move it tiny bit upper so we use 40% instead of 50% */
  left: 50%; /* 50% here refers to the parent's height/width */
  transform: translate(-50%, -50%); /* 50% here refers to the h/w of itself */
  text-align: center; /* center the button (inline-block) */
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  /* Determines whether or not the 'back' side of a transformed
   element is visible. With an identity transform, the 'front' side
   of an element faces the viewer.
   This removes some shaky side-effects (bugs) of animation.
   */
  backface-visibility: hidden;

  margin-bottom: 6rem;
}

.heading-primary--main {
  /* span element is by default an inline element */
  /* block elements occupy the entire width available and creates linebreak after and before them */
  display: block;
  font-size: 6rem;
  font-weight: 400;
  letter-spacing: 3.5rem;

  animation-name: moveInLeft;
  animation-duration: 1s;
  animation-timing-function: ease-out;
  /*
  animation-delay: 2s;
  animation-iteration-count: 3;
  */
}

.heading-primary--sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.7rem;

  animation: moveInRight 1s ease-out;
}

@keyframes moveInLeft {
  0% { /* initial state */
    opacity: 0;
    transform: translateX(-10rem);
  }
  /* can add multiple intermediate states here */
  70% { /* intermediate state */
    transform: translateX(.5rem);
  }
  100% { /* final state */
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }
  70% {
    transform: translateX(-.5rem);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* pseudo class - a special state of a selector */
.btn:link, /* unvisited links */
.btn:visited /* visited links */
{
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  font-size: 1.6rem;

  /* inline, block, inline-block
  - https://stackoverflow.com/questions/9189810/css-display-inline-vs-inline-block
  - http://dustwell.com/div-span-inline-block.html
  - https://hacks.mozilla.org/2015/03/understanding-inline-box-model/
  inline element doesn't respect width or height or top/bottom padding/margin
  but we set top/bottom padding here so we should use inline-block
  */
  display: inline-block; /* treated as if this was text */

  transition: all .2s;

  border-radius: 10rem;

  position: relative; /* as the reference of .btn::after */
}

.btn:hover {
  transform: translateY(-.3rem); /* refer to the initial state (btn:link) */
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, .2);
}

.btn:active {
  transform: translateY(-.1rem); /* refer to the initial state (btn:link) */
  box-shadow: 0 .5rem 1rem rgba(0, 0, 0, .2);
}

/* according to CSS definition
a:hover must come after a:link and a:visited to be effective
a:active must come after a:hover to be effective
*/

.btn--white {
  background-color: #fff;
  color: #777;
}

/* pseudo element - a virtual element */
.btn::after {
  content: ""; /* without this it doesn't show anything */
  display: inline-block;
  height: 100%; /* pseudo element is treated as the child of the original element */
  width: 100%;
  border-radius: 10rem;

  /* an absolute-positioned element needs a reference,
  which is the first relative-positioned element it can find*/
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all .4s;
}

.btn--white::after {
  /* this itself doesn't show up as it doesn't have content property,
  but as <a> has both .btn and .btn-white,
  and an element can have only one ::after element,
  so the properties of .btn::after and .btn-white::after will
  be merged and applied to a single ::after element of <a>
  */
  background-color: white;
}

/* TODO? https://www.udemy.com/advanced-css-and-sass/learn/v4/questions/3162218 */

.btn:hover::after {
  transform: scale(1.4, 1.6); /* transform from original state, original state is .btn:hover */
  opacity: 0;
}

.btn--animated {
  animation: moveInBottom .5s ease-out .75s; /* animation-delay set to be .75s */
  animation-fill-mode: backwards; /* use the properties defined in 0% to fill before animation starts */
}
