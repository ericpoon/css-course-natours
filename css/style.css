/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/*
browsers are getting better and better
so now we don't need normalize.css for cross browser reset
we can just simply use the universal selector to do it
*/
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/*
body is the parent of all the other elements
and font properties are usually inherited
so they will be applied to all child elements
this is more efficient and better practice, compared to putting all in universal selector
everything related to font we always specify here
*/
body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  font-size: 16px;
  line-height: 1.7;
  color: #777;
  padding: 30px; /* to make entire body has a white border */
}

.header {
  height: 95vh;
  background-image: linear-gradient(
      to right bottom,
      rgba(126, 213, 111, 0.8),
      rgba(40, 180, 131, 0.8)
  ), url(../img/hero.jpg);
  background-size: cover; /* cover means always try to fit */
  background-position: top; /* the fixed edge of the image */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%); /* can use online css clip-path maker */

  position: relative; /* if child elements are positioned using 'absolute', this will be the origin */
}

/* difference between viewport height and percentage
viewport size is the browser window size which includes scrollbar
while % is the actual element w/h
also, vw/vh refers to viewport size no matter how nested the element is
in short,
for width, % may be better (so don't worry about scrollbar)
for height, vh may be better (can't make an element 100% height with %)
reference: https://bitsofco.de/viewport-vs-percentage-units/
*/

.logo-box {
  position: absolute;
  top: 40px; /* count from the first relative-positioned ancestor */
  left: 40px;
}

.logo {
  /* the width will scale accordingly,
   can also control width and let browser figure out the height as well */
  height: 35px;
}

.text-box {
  position: absolute;
  top: 40%; /* move it tiny bit upper so we use 40% instead of 50% */
  left: 50%; /* 50% here refers to the parent's height/width */
  transform: translate(-50%, -50%); /* 50% here refers to the h/w of itself */
  text-align: center; /* center the button (inline-block) */
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  /* Determines whether or not the 'back' side of a transformed
   element is visible. With an identity transform, the 'front' side
   of an element faces the viewer.
   This removes some shaky side-effects (bugs) of animation.
   */
  backface-visibility: hidden;

  margin-bottom: 60px;
}

.heading-primary-main {
  /* span element is by default an inline element */
  /* block elements occupy the entire width available and creates linebreak after and before them */
  display: block;
  font-size: 60px;
  font-weight: 400;
  letter-spacing: 35px;

  animation-name: moveInLeft;
  animation-duration: 1s;
  animation-timing-function: ease-out;
  /*
  animation-delay: 2s;
  animation-iteration-count: 3;
  */
}

.heading-primary-sub {
  display: block;
  font-size: 20px;
  font-weight: 700;
  letter-spacing: 17.4px;

  animation: moveInRight 1s ease-out;
}

@keyframes moveInLeft {
  0% { /* initial state */
    opacity: 0;
    transform: translateX(-100px);
  }
  /* can add multiple intermediate states here */
  70% { /* intermediate state */
    transform: translateX(5px);
  }
  100% { /* final state */
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(100px);
  }
  70% {
    transform: translateX(-5px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* pseudo class - a special state of a selector */
.btn:link, /* unvisited links */
.btn:visited /* visited links */
{
  text-transform: uppercase;
  text-decoration: none;
  padding: 15px 40px;

  /* inline, block, inline-block
  - https://stackoverflow.com/questions/9189810/css-display-inline-vs-inline-block
  - http://dustwell.com/div-span-inline-block.html
  - https://hacks.mozilla.org/2015/03/understanding-inline-box-model/
  inline element doesn't respect width or height or top/bottom padding/margin
  but we set top/bottom padding here so we should use inline-block
  */
  display: inline-block; /* treated as if this was text */

  transition: all .2s;

  border-radius: 100px;

  position: relative; /* as the reference of .btn::after */
}

.btn:hover {
  transform: translateY(-3px); /* refer to the initial state (btn:link) */
  box-shadow: 0 10px 20px rgba(0, 0, 0, .2);
}

.btn:active {
  transform: translateY(-1px); /* refer to the initial state (btn:link) */
  box-shadow: 0 5px 10px rgba(0, 0, 0, .2);
}

/* according to CSS definition
a:hover must come after a:link and a:visited to be effective
a:active must come after a:hover to be effective
*/

.btn-white {
  background-color: #fff;
  color: #777;
}

/* pseudo element - a virtual element */
.btn::after {
  content: ""; /* without this it doesn't show anything */
  display: inline-block;
  height: 100%; /* pseudo element is treated as the child of the original element */
  width: 100%;
  border-radius: 100px;

  /* an absolute-positioned element needs a reference,
  which is the first relative-positioned element it can find*/
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all .4s;
}

.btn-white::after {
  /* this itself doesn't show up as it doesn't have content property,
  but as <a> has both .btn and .btn-white,
  and an element can have only one ::after element,
  so the properties of .btn::after and .btn-white::after will
  be merged and applied to a single ::after element of <a>
  */
  background-color: white;
}

/* TODO? https://www.udemy.com/advanced-css-and-sass/learn/v4/questions/3162218 */

.btn:hover::after {
  transform: scale(1.4, 1.6); /* transform from original state, original state is .btn:hover */
  opacity: 0;
}

.btn-animated {
  animation: moveInBottom .5s ease-out .75s; /* animation-delay set to be .75s */
  animation-fill-mode: backwards; /* use the properties defined in 0% to fill before animation starts */
}

/*
Lecture 14, Section 3

a CSS rule contains a 'selector' and a 'declaration block',
in a declaration block there are 'declarations',
and each declaration has 'property' and 'declared value'

CSS parsing includes 2 steps:
  1. resolve conflicting CSS declaration
  2. process final CSS values

Step 1 is also referred as the cascade:
  Process of combining different stylesheets and resolving conflicts in 3 sources
  - author declarations (written by developers)
  - user declarations (due to user interaction/behaviour)
  - user agent declarations (default browser declarations)


  Priority: importance > specificity > source order
  - The cascade starts by giving each conflicting declaration an *importance*
    importance level:
      - user !important declarations
      - author !important declarations
      - auth declarations
      - user declarations
      - user agent declarations
  - If same importance, then it compares *specificity*
    specificity level (according to the selector):
      - inline styles
      - IDs
      - classes, pseudo-classes, attributes
      - elements, pseudo-elements
    Note: see 9:01 in lecture 14 for how it counts specificity
  - If same specificity, then it compares *source order*
    use the last declaration to override all previous declarations

  Note:
    - Only use !important as a last resource,
      it's always better to use correct specificities for more maintainable code
    - Universal selector * has no specificity value, it's (0, 0, 0, 0)
    - Rely more on specificity
    - When using 3rd party stylesheets, always put the author stylesheets last,
      so what the developer writes won't be overridden
*/

/*
Lecture 16, Section 3

Step 2 of parsing CSS - process final CSS values

Note that all units (%, vh, vw, etc.) are ultimately converted into px in this step

How CSS values are processed:
  There are 6 types of values, during the process:
  1) Declared value
    - author declarations
  2) Cascaded value
    - after cascade (resolving conflicts)
  3) Specified value
    - giving a default/initial value, if there is not cascaded value
    - inheritance plays a role here
  4) Computed value
    - converting relative values to absolute (converting units into px)
  5) Used value
    - final calculations, based on layout
    - this happens later in rendering phase
  6) Actual value
    - due to browser and device restrictions, floating point may be rounded

How units are converted from relative to absolute (px)
  There are two types of percentage:
  1) percentage for fonts:    x% * parent's computed *font-size*
  2) percentage for lengths:  x% * parent's computed *width*

  There are also three types of *font-based units*:
  1) em for fonts:            x * parent's computed font-size
  2) em for lengths:          x * current element's computed font-size
  3) rem:                     x * root's computed font-size
     (calculation way of rem is the same for fonts and lengths)
  - font-based units give us flexibility, we only need to change font size to change all elements' sizes,
    this is a great technique for responsive layout

  Two more viewport-based units
  1) vw:                      x% of the viewport width
  1) vh:                      x% of the viewport height

Summary
  - each property has an initial value, used if nothing is declared and no inheritance
  - browsers specify a root font-size for each page (usually 16px)
  - % and relative values are always converted to px
    - % - relative to parent's font-size, for font-size
    - % - relative to parent's width, for lengths
    - em - relative to parent's font-size, for font-size
    - em - relative to current font-size, for lengths
    - rem - relative to root's font-size, for both font-size and lengths
    - vw, vh - percentage measurements of viewport's view and height
*/